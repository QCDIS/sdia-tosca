tosca_definitions_version: tosca_simple_yaml_1_2
description: TOSCA example
imports:
- nodes: https://raw.githubusercontent.com/qcdis-sdia/sdia-tosca/master/types/nodes.yaml
- data: https://raw.githubusercontent.com/qcdis-sdia/sdia-tosca/master/types/data.yml
- capabilities: https://raw.githubusercontent.com/qcdis-sdia/sdia-tosca/master/types/capabilities.yaml
- policies: https://raw.githubusercontent.com/qcdis-sdia/sdia-tosca/master/types/policies.yaml
- interfaces: https://raw.githubusercontent.com/qcdis-sdia/sdia-tosca/master/types/interfaces.yml
topology_template:
  node_templates:
    {% for vm in vms %}
      {{ vm['name'] }}:
      interfaces:
        Standard:
          create: dummy.yaml
      properties:
        role: {{ vm['role'] }}
        assign_public_ip: {{ vm['assign_public_ip'] }}
        disk_size: {{ vm['disk_size'] }} MB
        mem_size: {{ vm['mem_size'] }} MB
        num_cores: {{ vm['num_cores'] }}
        os_distro: Ubuntu
        os_version: 18.04
        user_name: {{ vm['user_name'] }}
      type: tosca.nodes.QC.VM.Compute
    {% endfor %}
    topology:
      properties:
        domain: {{ topology['domain'] }}
        provider: {{ topology['provider'] }}
      requirements:
        {% for vm in vms %}
      - vm:
          capability: tosca.capabilities.QC.VM
          node: {{ vm['name'] }}
          relationship: tosca.relationships.DependsOn
        {% endfor %}
      type: tosca.nodes.QC.VM.topology
      interfaces:
        EC2:
          create:
            implementation: vm/create_vms.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              extra_variables:
                region: {{ topology['domain'] }}
                availability_zone: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      instances:
                      {% for vm in vms %}
                        {{ vm['name'] }}:
                          disk_size: {{ vm['disk_size'] }}
                          mem_size: {{ vm['mem_size'] }}
                          num_cores: {{ vm['num_cores'] }}
                          os_distro: { get_property: [ {{ vm['name'] }}, os_distro ] }
                          os_version: { get_property: [ {{ vm['name'] }}, os_version ] }
                          user_name: {{ vm['user_name'] }}
                          role: {{ vm['role'] }}
                          assign_public_ip: {{ vm['assign_public_ip'] }}
                      {% endfor %}
          create_security_group:
            implementation: security_groups.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
          create_vpc_subnet:
            implementation: network/create_vpc_subnet.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
          create_vpc:
            implementation: network/create_vpc.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
          select_instance_type:
            implementation: info/get_inst_flavors.yaml
            inputs:
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      credentials: { get_attribute: [ topology, credentials ] }
                      instances:
                      {% for vm in vms %}
                        {{ vm['name'] }}:
                          disk_size: {{ vm['disk_size'] }}
                          mem_size: {{ vm['mem_size'] }}
                          num_cores: {{ vm['num_cores'] }}
                      {% endfor %}
              repository: https://github.com/QCDIS/ec2_playbooks.git
          select_image:
            implementation: info/get_images.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      instances:
                      {% for vm in vms %}
                        {{ vm['name'] }}:
                          os_distro: { get_property: [ {{ vm['name'] }}, os_distro ] }
                          os_version: { get_property: [ {{ vm['name'] }}, os_version ] }
                      {% endfor %}
          create_ssh_key:
            implementation: key/create_keys.yaml
            inputs:
              extra_variables:
                region: {{ topology['domain'] }}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      instances:
                      {% for vm in vms %}
                        {{ vm['name'] }}:
                          os_distro: { get_property: [ {{ vm['name'] }}, os_distro ] }
                          os_version: { get_property: [ {{ vm['name'] }}, os_version ] }
                      {% endfor %}
              repository: https://github.com/QCDIS/ec2_playbooks.git
          delete_ssh_key:
            implementation: key/delete_key.yaml
            inputs:
              extra_variables:
                region: {{ topology['domain'] }}
                {% for vm in vms %}
                {% if vm['role'] == 'master' %}
                random_name: { get_attribute: [ vm['name'], random_name ] }
                {% endif %}
                {% endfor %}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
              repository: https://github.com/QCDIS/ec2_playbooks.git
          delete:
            implementation: vm/delete_vms.yaml
            inputs:
              extra_variables:
                region: {{ topology['domain'] }}
                {% for vm in vms %}
                {% if vm['role'] == 'master' %}
                random_name: { get_attribute: [ vm['name'], random_name ] }
                {% endif %}
                {% endfor %}
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      instances:
                        {% for vm in vms %}
                          {{ vm['name'] }}:
                          id: { get_attribute: [ vm['name'], id ] }
                        {% endfor %}
              repository: https://github.com/QCDIS/ec2_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
              repository: https://github.com/QCDIS/ec2_playbooks.git
          create_random_name:
            implementation: random_name.yaml
            inputs:
              repository: https://github.com/QCDIS/ec2_playbooks.git
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
          create_user:
            implementation: create_users.yaml
            inputs:
              extra_variables:
                ansible_ssh_user: ubuntu
              repository: https://github.com/QCDIS/ec2_playbooks.git
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
                      instances:
                      {% for vm in vms %}
                        {{ vm['name'] }}:
                          user_name : {{ vm['user_name'] }}
                      {% endfor %}
          set_attributes:
            implementation: set_attributes.yaml
            inputs:
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
              repository: https://github.com/QCDIS/ec2_playbooks.git
    nfs:
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - host:
            capability: "tosca.capabilities.QC.VM.topology"
            node: "topology"
            relationship: "tosca.relationships.HostedOn"
      interfaces:
        NFS:
          install:
            implementation: "install_nfs.yaml"
            inputs:
              extra_variables:
                mount_path: "/data/nfs-data"
              inventory:
                all:
                  children:
                    nfs-server:
                      hosts:
                      {% for vm in vms %}
                      {% if vm['role'] == 'master' %}
                        hlf0:
                          ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                          ansible_python_interpreter: /usr/bin/python3
                          ansible_ssh_user:  {{ vm['user_name'] }}
                      {% endif %}
                      {% endfor %}
              repository: "https://github.com/QCDIS/nfs_playbooks.git"
          requirements:
            implementation: "install_requirements.yaml"
            inputs:
              inventory:
                all:
                  hosts:
                    localhost:
                      ansible_connection: local
              repository: "https://github.com/QCDIS/nfs_playbooks.git"
          set_attributes:
            implementation: "set_attributes.yml"
            inputs:
              inventory:
                all:
                  children:
                    nfs-server:
                      hosts:
                      {% for vm in vms %}
                      {% if vm['role'] == 'master' %}
                        hlf0:
                          ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                          ansible_python_interpreter: /usr/bin/python3
                          ansible_ssh_user:  {{ vm['user_name'] }}
                      {% endif %}
                      {% endfor %}
              repository: "https://github.com/QCDIS/nfs_playbooks.git"
      type: "tosca.nodes.QC.Application.NFS"
    kubernetes:
      type: "tosca.nodes.QC.docker.Orchestrator.Kubernetes"
      requirements:
        - host:
            capability: "tosca.capabilities.QC.VM.topology"
            node: "topology"
            relationship: "tosca.relationships.HostedOn"
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
            credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      interfaces:
        Kubernetes:
          install_requirements:
            implementation: install_prerequisites.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          install_k8s:
            implementation: install_k8s.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          set_master:
            implementation: set_master_k8s_cluster.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          join_k8s_cluster:
            implementation: join_k8s_cluster.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          create_k8s_dashboard:
            implementation: create_k8s_dashboard.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          create_k8s_metrics_server:
            implementation: create_k8s_metrics_server.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          scale:
          autoscale:
          info:
          set_attributes:
            implementation: get_attributes.yaml
            inputs:
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          create_persistent_volume:
            implementation: create_persistent_volume.yaml
            inputs:
              extra_variables:
                storage_capacity: 10Gi
                local_path: /mnt/disk/vol1
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
          reset_k8s_cluster:
            implementation: create_persistent_volume.yaml
            inputs:
              extra_variables:
                storage_capacity: 10Gi
                local_path: /mnt/disk/vol1
              repository: "https://github.com/QCDIS/k8s_playbooks.git"
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
    ingress:
      interfaces:
        Helm:
          install_chart:
            implementation: install_chart.yaml
            inputs:
              extra_variables:
                chart_name: ingress-nginx/nginx-ingress
                helm_name: ingress-nginx
                namespace: default
                repo_name: ingress-nginx
                repo_url: https://kubernetes.github.io/ingress-nginx
                values:
                  controller:
                    service:
                      type: NodePort
                      nodePorts:
                        http: 32080
                        https: {{ ingress_ssl_port }}
                        tcp:
                          8080: 32808
                  ingressClassResource:
                    default: true
              inventory:
                all:
                  hosts:
                    master:
                      ansible_host:
                        get_attribute:
                          - compute
                          - public_ip
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:
                        get_property:
                          - compute
                          - user_name
              repository: https://github.com/QCDIS/helm_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% else %}
                    worker:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user: {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - kubernetes:
            capability: tosca.capabilities.QC.Kubernetes
            node: kubernetes
            relationship: tosca.relationships.HostedOn
      type: tosca.nodes.QC.Container.Application.Helm
    nfs-provisioner:
      interfaces:
        Helm:
          install_chart:
            implementation: install_chart.yaml
            inputs:
              extra_variables:
                chart_name: nfs-subdir-external-provisioner/nfs-subdir-external-provisioner
                helm_name: nfs-provisioner
                namespace: default
                repo_name: nfs-subdir-external-provisioner
                repo_url: https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/
                values:
                  nfs:
                    {% for vm in vms %}
                      {% if vm['role'] == 'master' %}
                    server:  { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      {% endif %}
                      {% endfor %}
                    path: /data/nfs-data
                    storageClass:
                      name: nfs
                      defaultClass: true
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - kubernetes:
            capability: tosca.capabilities.QC.Kubernetes
            node: kubernetes
            relationship: tosca.relationships.HostedOn
      type: tosca.nodes.QC.Container.Application.Helm
    jupyterhub:
      interfaces:
        Helm:
          install_chart:
            implementation: install_chart.yaml
            inputs:
              extra_variables:
                chart_name: jupyterhub/jupyterhub
                helm_name: jupyterhub
                namespace: default
                repo_name: jupyterhub
                repo_url: https://jupyterhub.github.io/helm-chart/
                values:
                  hub:
                    initContainers:
                      - name: git-clone-templates
                        image: alpine/git
                        args:
                          - clone
                          - --single-branch
                          - --branch=lifeWatch
                          - --depth=1
                          - --
                          - https://github.com/QCDIS/k8s-jhub.git
                          - /etc/jupyterhub/custom
                        securityContext:
                          runAsUser: 0
                        volumeMounts:
                          - name: hub-templates
                            mountPath: /etc/jupyterhub/custom
                    extraVolumes:
                      - name: hub-templates
                        emptyDir: { }
                    extraVolumeMounts:
                      - name: hub-templates
                        mountPath: /etc/jupyterhub/custom
                    extraConfig:
                      templates: |
                        c.JupyterHub.template_paths = ['/etc/jupyterhub/custom/templates']
                    concurrentSpawnLimit: 20
                    consecutiveFailureLimit: 20
                    activeServerLimit: 20
                    namedServerLimitPerUser: 1
                    shutdownOnLogout: true
                    extraEnv:
                      OAUTH2_TLS_VERIFY: 'false'
                    baseUrl: /n-a-a-vre
                    config:
                      GenericOAuthenticator:
                        client_id: {{ auth['client_id'] }}
                        client_secret: {{ auth['client_secret'] }}
                        oauth_callback_url: https://{{ fqdn }}:{{ ingress_ssl_port }}/{{ auth['realm_name'] }}/hub/oauth_callback
                        authorize_url: https://{{ auth['keycloak_host'] }}:{{ ingress_ssl_port }}/auth/realms/{{ auth['realm_name'] }}/protocol/openid-connect/auth
                        token_url: https://{{ auth['keycloak_host'] }}:{{ ingress_ssl_port }}/auth/realms/{{ auth['realm_name'] }}/protocol/openid-connect/token
                        userdata_url: https://{{ auth['keycloak_host'] }}:{{ ingress_ssl_port }}/auth/realms/{{ auth['realm_name'] }}/protocol/openid-connect/userinfo
                        login_service: keycloak
                        username_key: preferred_username
                        userdata_params:
                          state: state
                      JupyterHub:
                        authenticator_class: generic-oauth
                        tornado_settings:
                          headers:
                            Content-Security-Policy: "frame-ancestors 'self' *"
                          cookie_options:
                            SameSite: "None"
                            Secure: "True"
                        tls_verify: false
                  ingress:
                    enabled: true
                    annotations:
                      kubernetes.io/ingress.class: "nginx"
                      nginx.ingress.kubernetes.io/add-base-url: "true"
                      kubernetes.io/tls-acme: "true"
                    tls:
                      - hosts:
                        - {{ fqdn }}
                        secretName: {{ fqdn }}-tls
                  proxy:
                    service:
                      type: ClusterIP
                  singleuser:
                    lifecycleHooks:
                      postStart:
                        exec:
                          command:
                            - "sh"
                            - "-c"
                            - >
                              {{ init_script }}
                    profileList:
                      {% for profile in profile_list %}
                    - display_name: {{ profile['display_name'] }}
                      description: {{ profile['description'] }}
                      default: {{ profile['is_default'] }}
                      kubespawner_override:
                        image: {{ profile['image'] }}
                      {% endfor %}
                    defaultUrl: "/lab"
                    extraEnv:
                      JUPYTERHUB_SINGLEUSER_APP: "jupyter_server.serverapp.ServerApp"
                    image:
                      name: {{ default_profile['image'] }}
                      tag: {{ default_profile['image']['tag'] }}
                      pullPolicy: Always
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - kubernetes:
            capability: tosca.capabilities.QC.Kubernetes
            node: kubernetes
            relationship: tosca.relationships.HostedOn
      type: tosca.nodes.QC.Container.Application.Helm
    argowf:
      interfaces:
        Helm:
          install_chart:
            implementation: install_chart.yaml
            inputs:
              extra_variables:
                chart_name: argo/argo-workflows
                helm_name: argowf
                namespace: default
                repo_name: argo
                repo_url: https://argoproj.github.io/argo-helm
                values:
                  controller:
                    containerRuntimeExecutor: emissary
                  server:
                    extraArgs:
                      - --auth-mode=sso
                    enabled: true
                    baseHref: /argowf/
                    serviceType: ClusterIP
                    #https://github.com/argoproj/argo-workflows/blob/master/docs/argo-server-sso.md
                    sso:
                      issuer: {{ auth['issuer'] }}
                      sessionExpiry: 240h
                      clientId:
                        name: argo-sso
                        key: client-id-key
                      clientSecret:
                        name: argo-sso
                        key: client-secret-key
                      redirectUrl: https://{{ fqdn }}:{{ ingress_ssl_port }}/argowf/oauth2/callback
                      rbac:
                        enabled: false
                      insecureSkipVerify: false
                    ingress:
                      enabled: true
                      ingressClassName: "nginx"
                      annotations:
                        nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
                        nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
                        nginx.ingress.kubernetes.io/rewrite-target: /$2
                        nginx.ingress.kubernetes.io/add-base-url: "true"
                        nginx.ingress.kubernetes.io/configuration-snippet: |
                          proxy_set_header Accept-Encoding "";
                          sub_filter '<base href="/">' '<base href="/argowf/">';
                          sub_filter_once on;
                      hosts:
                        - {{ fqdn }}
                      paths:
                        - /argowf(/|$)(.*)
                      tls:
                        - hosts:
                            - {{ fqdn }}
                          secretName: {{ fqdn }}-tls
              inventory:
                all:
                  hosts:
                    master:
                      ansible_host:
                        get_attribute:
                          - compute
                          - public_ip
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:
                        get_property:
                          - compute
                          - user_name
              repository: https://github.com/QCDIS/helm_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - kubernetes:
            capability: tosca.capabilities.QC.Kubernetes
            node: kubernetes
            relationship: tosca.relationships.HostedOn
      type: tosca.nodes.QC.Container.Application.Helm
    minio:
      interfaces:
        Helm:
          install_chart:
            implementation: install_chart.yaml
            inputs:
              extra_variables:
                chart_name: bitnami/minio
                helm_name: minio
                namespace: default
                repo_name: minio
                repo_url: https://charts.bitnami.com/bitnami
                values:
                  apiIngress:
                    enabled: true
                    hostname: {{ fqdn }}
                    tls: true
                    selfSigned: true
                  ingress:
                    tls: true
                    selfSigned: true
                    hostname: {{ fqdn }}
                  persistence:
                    enabled: false
                  service:
                    type: NodePort
                    nodePorts:
                      api: 32445
                      console: 32444
              inventory:
                all:
                  hosts:
                    master:
                      ansible_host:
                        get_attribute:
                          - compute
                          - public_ip
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:
                        get_property:
                          - compute
                          - user_name
              repository: https://github.com/QCDIS/helm_playbooks.git
          install_requirements:
            implementation: install_requirements.yaml
            inputs:
              inventory:
                all:
                  hosts:
                  {% for vm in vms %}
                  {% if vm['role'] == 'master' %}
                    master:
                      ansible_host: { get_attribute: [ {{ vm['name'] }},public_ip ] }
                      ansible_python_interpreter: /usr/bin/python3
                      ansible_ssh_user:  {{ vm['user_name'] }}
                  {% endif %}
                  {% endfor %}
              repository: https://github.com/QCDIS/helm_playbooks.git
      properties:
      {% for vm in vms %}
        {% if vm['role'] == 'master' %}
        credential: { get_attribute: [ vm['name'],user_key_pair ] }
        {% endif %}
      {% endfor %}
      requirements:
        - kubernetes:
            capability: tosca.capabilities.QC.Kubernetes
            node: kubernetes
            relationship: tosca.relationships.HostedOn
      type: tosca.nodes.QC.Container.Application.Helm

  workflows:
    NaaVRE-deploy:
      description: deploy all
      preconditions:
        - target: topology
          condition:
            - assert:
              - current_state: [{equal: RUNNING }]
        - target: kubernetes
          condition:
            - assert:
              - desired_state: [{equal: RUNNING }]
              - current_state: [{equal: UNDEFINED }]
      steps:
        deploy_nfs-requirements:
          activities:
          - call_operation: NFS.requirements
            on_success: deploy_nfs-install
          target: nfs
        deploy_nfs-install:
          activities:
          - call_operation: NFS.install
            on_success:
            - NaaVRE_jupyterhub_install_heml_requirements
            - deploy_nfs-set-attributes
          target: nfs
        deploy_nfs-set-attributes:
          activities:
          - call_operation: NFS.set_attributes
          - set_state: created
          target: nfs
        NaaVRE_jupyterhub_install_k8s_requirements:
          activities:
          - set_state: CREATING
          - call_operation: Kubernetes.install_requirements
            on_success:
            - NaaVRE_jupyterhub_install_k8s
          target: kubernetes
        NaaVRE_jupyterhub_install_k8s:
          activities:
          - call_operation: Kubernetes.install_k8s
            on_success: NaaVRE_jupyterhub_set_master
          target: kubernetes
        NaaVRE_jupyterhub_set_master:
          activities:
          - call_operation: Kubernetes.set_master
            on_success:
            - deploy_nfs-requirements
            - NaaVRE_jupyterhub_join_k8s_cluster
            - NaaVRE_jupyterhub_create_k8s_dashboard
          target: kubernetes
        NaaVRE_jupyterhub_join_k8s_cluster:
          activities:
          - call_operation: Kubernetes.join_k8s_cluster
            on_success:
              - NaaVRE_jupyterhub_install_ingress
              - NaaVRE_jupyterhub_install_nfs-provisioner
              - NaaVRE_jupyterhub_install_jupyterhub
              - NaaVRE_jupyterhub_install_postgresql
              - NaaVRE_jupyterhub_install_keycloak
          target: kubernetes
        NaaVRE_jupyterhub_install_heml_requirements:
          activities:
          - call_operation: Helm.install_requirements
            on_success:
              - NaaVRE_jupyterhub_install_ingress
              - NaaVRE_jupyterhub_install_nfs-provisioner
              - NaaVRE_jupyterhub_install_jupyterhub
              - NaaVRE_jupyterhub_install_postgresql
              - NaaVRE_jupyterhub_install_keycloak
          target:  jupyterhub
        NaaVRE_jupyterhub_install_jupyterhub:
          activities:
          - call_operation: Helm.install_chart
            on_success: NaaVRE_jupyterhub_set_k8s_attributes
          - set_state: RUNNING
          target: jupyterhub
        NaaVRE_jupyterhub_install_keycloak:
          activities:
          - call_operation: Helm.install_chart
            on_success: NaaVRE_jupyterhub_set_k8s_attributes
          - set_state: RUNNING
          target: keycloak
        NaaVRE_jupyterhub_install_postgresql:
          activities:
          - call_operation: Helm.install_chart
            on_success: NaaVRE_jupyterhub_set_k8s_attributes
          - set_state: RUNNING
          target: postgresql
        NaaVRE_jupyterhub_install_nfs-provisioner:
          activities:
          - call_operation: Helm.install_chart
            on_success: NaaVRE_jupyterhub_set_k8s_attributes
          - set_state: RUNNING
          target: nfs-provisioner
        NaaVRE_jupyterhub_install_ingress:
          activities:
          - call_operation: Helm.install_chart
            on_success: NaaVRE_jupyterhub_set_k8s_attributes
          - set_state: RUNNING
          target: ingress
        NaaVRE_jupyterhub_set_k8s_attributes:
          activities:
          - call_operation: Kubernetes.set_attributes
          target: kubernetes
        NaaVRE_jupyterhub_create_k8s_dashboard:
          activities:
          - call_operation: Kubernetes.create_k8s_dashboard
          target: kubernetes

    ec2_provision:
      description: Workflow to deploy ec2 topology
      preconditions:
        - target: topology
          condition:
            - assert:
              - desired_state: [{equal: RUNNING }]
              - current_state: [{equal: UNDEFINED }]
      steps:
          ec2_install_requirements:
            activities:
            - set_state: CREATING
            - call_operation: EC2.install_requirements
              on_success:
              - ec2_select_instance_type
              - ec2_select_image
              - ec2_create_ssh_key
            target: topology
          ec2_create_random_name:
            activities:
            - call_operation: EC2.create_random_name
              on_success:
              - ec2_select_instance_type
              - ec2_select_image
              - ec2_create_ssh_key
            target: topology
          ec2_select_instance_type:
            activities:
            - set_state: CREATING
            - call_operation: EC2.select_instance_type
              on_success:
                - ec2_create
            target: topology
          ec2_select_image:
            activities:
            - set_state: CREATING
            - call_operation: EC2.select_image
              on_success:
                - ec2_create
            target: topology
          ec2_create_ssh_key:
            activities:
            - set_state: CREATING
            - call_operation: EC2.create_ssh_key
              on_success:
                - ec2_create
            target: topology
          ec2_create:
            activities:
            - call_operation: EC2.create
              on_success:
              - ec2_create_user
            - set_state: RUNNING
            target: topology
          ec2_set_attributes:
            activities:
            - call_operation: EC2.set_attributes
            target: topology
          ec2_create_user:
            activities:
            - call_operation: EC2.create_user
              on_success:
              - ec2_set_attributes
            target: topology

    ec2_delete_topology:
      description: delete_topology
      preconditions:
        - target: topology
          condition:
            - assert:
              - desired_state: [{equal: DELETED }]
              - current_state: [{equal: RUNNING }]
      steps:
        delete:
          activities:
          - set_state: DELETING
          - call_operation: EC2.delete
            on_success:
            - set_attributes
          - set_state: DELETED
          target: topology
        delete_ssh:
          activities:
          - set_state: DELETING
          - call_operation: EC2.delete_ssh_key
            on_success:
            - set_attributes
          target: topology
        set_attributes:
          activities:
          - call_operation: EC2.set_attributes
          target: topology
